package zip

import (
	"archive/zip"
	"io"
	"os"
	"path/filepath"
)

/*
Disclaimer:
	This code was largely generated by GitHub Copilot.
TODO:
	- test functions
	- optimize using library functions
*/

// TmpDir is the directory used to read and write zip files and their contents.
const TmpDir = "./tmp"

// Process extracts the zip file at the given path to the tmp directory. If the
// zip file contains a directory, it is created in the tmp directory. If the zip
// file contains a regular file, it is created in the tmp directory and its
// contents are copied from the zip file.
func Process(zPath string) error {
	// Open a zip archive for reading.
	r, err := zip.OpenReader(zPath)
	if err != nil {
		return err
	}
	defer r.Close()

	// Create a tmp directory to extract the zip file to.
	if err := os.MkdirAll(TmpDir, os.ModePerm); err != nil {
		return err
	}

	// Extract the zip file to the tmp directory.
	for _, f := range r.File {
		if err := extractFile(f); err != nil {
			return err
		}
	}

	return nil
}

// extractFile extracts the given file from the zip archive to the tmp
// directory. If the file is a directory, it is created in the tmp directory. If
// the file is a regular file, it is created in the tmp directory and its
// contents are copied from the zip archive.
func extractFile(f *zip.File) error {
	// Open the file inside the zip archive.
	rc, err := f.Open()
	if err != nil {
		return err
	}
	defer rc.Close()

	// Create the file in the tmp directory.
	path := filepath.Join(TmpDir, f.Name)
	if f.FileInfo().IsDir() {
		if err := os.MkdirAll(path, os.ModePerm); err != nil {
			return err
		}
	} else {
		f, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, os.ModePerm)
		if err != nil {
			return err
		}
		defer f.Close()

		// Copy the file contents to the tmp file.
		if _, err := io.Copy(f, rc); err != nil {
			return err
		}
	}

	return nil
}

// Create creates a zip file at the given path from the contents of the tmp
// directory. If the tmp directory contains a directory, it is created in the
// zip file. If the tmp directory contains a regular file, it is created in the
// zip file and its contents are copied from the tmp directory.
func Create(zPath string) error {
	// Create a file to write the archive buffer to.
	f, err := os.Create(zPath)
	if err != nil {
		return err
	}
	defer f.Close()

	// Create a new zip archive.
	w := zip.NewWriter(f)
	defer w.Close()

	// Add files to the archive.
	if err := addFiles(w, TmpDir, ""); err != nil {
		return err
	}

	return nil
}

// addFiles walks the given path and adds files to the zip archive. If the path
// is a directory, it is walked recursively. If the path is a regular file, it
// is added to the zip archive.
func addFiles(w *zip.Writer, basePath, baseInZip string) error {
	files, err := os.ReadDir(basePath)
	if err != nil {
		return err
	}

	for _, f := range files {
		if f.IsDir() {
			if err := addFiles(w, filepath.Join(basePath, f.Name()), filepath.Join(baseInZip, f.Name())); err != nil {
				return err
			}
			continue
		}

		if err := addFile(w, filepath.Join(basePath, f.Name()), filepath.Join(baseInZip, f.Name())); err != nil {
			return err
		}
	}

	return nil
}

// addFile adds the file at the given path to the zip archive. The file is added
// to the zip archive at the given path.
func addFile(w *zip.Writer, filePath, inZipPath string) error {
	f, err := os.Open(filePath)
	if err != nil {
		return err
	}
	defer f.Close()

	// Get the file information.
	info, err := f.Stat()
	if err != nil {
		return err
	}

	// Create a header for the file.
	header, err := zip.FileInfoHeader(info)
	if err != nil {
		return err
	}

	// Change the name to the one we want in the zip.
	header.Name = inZipPath

	// Set the compression method to deflate.
	header.Method = zip.Deflate

	// Create a writer for the file in the zip archive.
	writer, err := w.CreateHeader(header)
	if err != nil {
		return err
	}

	// Write the file to the zip.
	if _, err := io.Copy(writer, f); err != nil {
		return err
	}

	return nil
}

// Clean removes the tmp directory and its contents.
func Clean() error { return os.RemoveAll(TmpDir) }
